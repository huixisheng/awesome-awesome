(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{158:function(t,e,r){"use strict";r.r(e);var a=r(0),s=Object(a.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),r("p",[r("a",{attrs:{href:"https://travis-ci.org/trekhleb/javascript-algorithms",target:"_blank",rel:"noopener noreferrer"}},[r("img",{attrs:{src:"https://travis-ci.org/trekhleb/javascript-algorithms.svg?branch=master",alt:"build status"}}),r("OutboundLink")],1),r("a",{attrs:{href:"https://codecov.io/gh/trekhleb/javascript-algorithms",target:"_blank",rel:"noopener noreferrer"}},[r("img",{attrs:{src:"https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg",alt:"codecov"}}),r("OutboundLink")],1)]),r("p",[t._v("這個知識庫包含許多 JavaScript 的資料結構與演算法的基礎範例。\n每個演算法和資料結構都有其個別的文件，內有相關的解釋以及更多相關的文章或Youtube影片連結。")]),r("p",[r("em",[t._v("Read this in other languages:")]),r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/",target:"_blank",rel:"noopener noreferrer"}},[r("em",[t._v("English")]),r("OutboundLink")],1),t._v(",\n"),r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("简体中文"),r("OutboundLink")],1)]),t._m(1),r("p",[t._v("資料結構是一個電腦用來組織和排序資料的特定方式，透過這樣的方式資料可以有效率地被讀取以及修改。更精確地說，一個資料結構是一個資料值的集合、彼此間的關係，函數或者運作可以應用於資料上。")]),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/linked-list",target:"_blank",rel:"noopener noreferrer"}},[t._v("Linked List 鏈結串列"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/queue",target:"_blank",rel:"noopener noreferrer"}},[t._v("Queue 貯列"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/stack",target:"_blank",rel:"noopener noreferrer"}},[t._v("Stack 堆疊"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/hash-table",target:"_blank",rel:"noopener noreferrer"}},[t._v("Hash Table 雜湊表"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/heap",target:"_blank",rel:"noopener noreferrer"}},[t._v("Heap 堆"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/priority-queue",target:"_blank",rel:"noopener noreferrer"}},[t._v("Priority Queue 優先貯列"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/trie",target:"_blank",rel:"noopener noreferrer"}},[t._v("Trie 字典樹"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/tree",target:"_blank",rel:"noopener noreferrer"}},[t._v("Tree 樹"),r("OutboundLink")],1),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/tree/binary-search-tree",target:"_blank",rel:"noopener noreferrer"}},[t._v("Binary Search Tree 二元搜尋樹"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/tree/avl-tree",target:"_blank",rel:"noopener noreferrer"}},[t._v("AVL Tree \b\bAVL樹"),r("OutboundLink")],1)]),r("li",[t._v("紅黑樹")]),r("li",[t._v("後綴樹")]),r("li",[t._v("線段樹 或 間隔樹")]),r("li",[t._v("樹狀數組或二叉索引樹")])])]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/graph",target:"_blank",rel:"noopener noreferrer"}},[t._v("Graph 圖"),r("OutboundLink")],1),t._v(" (有向跟無向皆包含)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/disjoint-set",target:"_blank",rel:"noopener noreferrer"}},[t._v("Disjoint Set 互斥集"),r("OutboundLink")],1)])]),t._m(2),r("p",[t._v("演算法是一個如何解決一類問題的非模糊規格。演算法是一個具有精確地定義了一系列運作的規則的集合")]),t._m(3),r("ul",[r("li",[r("strong",[t._v("數學類")]),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/factorial",target:"_blank",rel:"noopener noreferrer"}},[t._v("階層"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/fibonacci",target:"_blank",rel:"noopener noreferrer"}},[t._v("費伯納西數列"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/primality-test",target:"_blank",rel:"noopener noreferrer"}},[t._v("Primality Test"),r("OutboundLink")],1),t._v(" (排除法)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/euclidean-algorithm",target:"_blank",rel:"noopener noreferrer"}},[t._v("歐幾里得算法"),r("OutboundLink")],1),t._v(" - 計算最大公因數 (GCD)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/least-common-multiple",target:"_blank",rel:"noopener noreferrer"}},[t._v("最小公倍數"),r("OutboundLink")],1),t._v(" (LCM)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/integer-partition",target:"_blank",rel:"noopener noreferrer"}},[t._v("整數拆分"),r("OutboundLink")],1)])])]),r("li",[r("strong",[t._v("集合")]),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/cartesian-product",target:"_blank",rel:"noopener noreferrer"}},[t._v("笛卡爾積"),r("OutboundLink")],1),t._v(" - 多個集合的乘積")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/power-set",target:"_blank",rel:"noopener noreferrer"}},[t._v("冪集合"),r("OutboundLink")],1),t._v(" - 所有集合的子集合")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/permutations",target:"_blank",rel:"noopener noreferrer"}},[t._v("排列"),r("OutboundLink")],1),t._v(" (有/無重複)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/combinations",target:"_blank",rel:"noopener noreferrer"}},[t._v("组合"),r("OutboundLink")],1),t._v(" (有/無重複)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/fisher-yates",target:"_blank",rel:"noopener noreferrer"}},[t._v("洗牌算法"),r("OutboundLink")],1),t._v(" - 隨機置換一有限序列")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/longest-common-subsequnce",target:"_blank",rel:"noopener noreferrer"}},[t._v("最長共同子序列"),r("OutboundLink")],1),t._v(" (LCS)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/longest-increasing-subsequence",target:"_blank",rel:"noopener noreferrer"}},[t._v("最長遞增子序列"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/shortest-common-supersequence",target:"_blank",rel:"noopener noreferrer"}},[t._v("Shortest Common Supersequence"),r("OutboundLink")],1),t._v(" (SCS)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/knapsack-problem",target:"_blank",rel:"noopener noreferrer"}},[t._v("背包問題"),r("OutboundLink")],1),t._v(' - "0/1" and "Unbound" ones')]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/maximum-subarray",target:"_blank",rel:"noopener noreferrer"}},[t._v("最大子序列問題"),r("OutboundLink")],1),t._v(" - 暴力法以及動態編程的(Kadane's)版本")])])]),r("li",[r("strong",[t._v("字串")]),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/levenshtein-distance",target:"_blank",rel:"noopener noreferrer"}},[t._v("萊文斯坦距離"),r("OutboundLink")],1),t._v(" - 兩序列間的最小編輯距離")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/hamming-distance",target:"_blank",rel:"noopener noreferrer"}},[t._v("漢明距離"),r("OutboundLink")],1),t._v(" - number of positions at which the symbols are different")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/knuth-morris-pratt",target:"_blank",rel:"noopener noreferrer"}},[t._v("KMP 演算法"),r("OutboundLink")],1),t._v(" - 子字串搜尋")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/rabin-karp",target:"_blank",rel:"noopener noreferrer"}},[t._v("Rabin Karp 演算法"),r("OutboundLink")],1),t._v(" - 子字串搜尋")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/longest-common-substring",target:"_blank",rel:"noopener noreferrer"}},[t._v("最長共通子序列"),r("OutboundLink")],1)])])]),r("li",[r("strong",[t._v("搜尋")]),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/search/binary-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("二元搜尋"),r("OutboundLink")],1)])])]),r("li",[r("strong",[t._v("排序")]),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/bubble-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("氣泡排序"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/selection-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("選擇排序"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/insertion-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("插入排序"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/heap-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("堆排序"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/merge-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("合併排序"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/quick-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("快速排序"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/shell-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("希爾排序"),r("OutboundLink")],1)])])]),r("li",[r("strong",[t._v("樹")]),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/tree/depth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("深度優先搜尋"),r("OutboundLink")],1),t._v(" (DFS)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/tree/breadth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("廣度優先搜尋"),r("OutboundLink")],1),t._v(" (BFS)")])])]),r("li",[r("strong",[t._v("圖")]),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/depth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("深度優先搜尋"),r("OutboundLink")],1),t._v(" (DFS)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/breadth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("廣度優先搜尋"),r("OutboundLink")],1),t._v(" (BFS)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/dijkstra",target:"_blank",rel:"noopener noreferrer"}},[t._v("Dijkstra 演算法"),r("OutboundLink")],1),t._v(" - 找到所有圖頂點的最短路徑")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/bellman-ford",target:"_blank",rel:"noopener noreferrer"}},[t._v("Bellman-Ford 演算法"),r("OutboundLink")],1),t._v(" - 找到所有圖頂點的最短路徑")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/detect-cycle",target:"_blank",rel:"noopener noreferrer"}},[t._v("Detect Cycle"),r("OutboundLink")],1),t._v(" - for both directed and undirected graphs (DFS and Disjoint Set based versions)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/prim",target:"_blank",rel:"noopener noreferrer"}},[t._v("Prim’s 演算法"),r("OutboundLink")],1),t._v(" - finding Minimum Spanning Tree (MST) for weighted undirected graph")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/kruskal",target:"_blank",rel:"noopener noreferrer"}},[t._v("Kruskal’s 演算法"),r("OutboundLink")],1),t._v(" - finding Minimum Spanning Tree (MST) for weighted undirected graph")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/topological-sorting",target:"_blank",rel:"noopener noreferrer"}},[t._v("拓撲排序"),r("OutboundLink")],1),t._v(" - DFS method")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/articulation-points",target:"_blank",rel:"noopener noreferrer"}},[t._v("關節點"),r("OutboundLink")],1),t._v(" - Tarjan's algorithm (DFS based)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/bridges",target:"_blank",rel:"noopener noreferrer"}},[t._v("橋"),r("OutboundLink")],1),t._v(" - DFS based algorithm")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/eulerian-path",target:"_blank",rel:"noopener noreferrer"}},[t._v("尤拉路徑及尤拉環"),r("OutboundLink")],1),t._v(" - Fleury's algorithm - Visit every edge exactly once")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/hamiltonian-cycle",target:"_blank",rel:"noopener noreferrer"}},[t._v("漢彌爾頓環"),r("OutboundLink")],1),t._v(" - Visit every vertex exactly once")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/strongly-connected-components",target:"_blank",rel:"noopener noreferrer"}},[t._v("強連通組件"),r("OutboundLink")],1),t._v(" - Kosaraju's algorithm")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/travelling-salesman",target:"_blank",rel:"noopener noreferrer"}},[t._v("旅行推銷員問題"),r("OutboundLink")],1),t._v(" - shortest possible route that visits each city and returns to the origin city")])])]),r("li",[r("strong",[t._v("未分類")]),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/hanoi-tower",target:"_blank",rel:"noopener noreferrer"}},[t._v("河內塔"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/n-queens",target:"_blank",rel:"noopener noreferrer"}},[t._v("N-皇后問題"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/knight-tour",target:"_blank",rel:"noopener noreferrer"}},[t._v("騎士走棋盤"),r("OutboundLink")],1)])])])]),t._m(4),r("p",[t._v("演算法的範型是一個泛用方法或設計一類底層演算法的方式。它是一個比演算法的概念更高階的抽象化，就像是演算法是比電腦程式更高階的抽象化。")]),r("ul",[r("li",[r("strong",[t._v("暴力法")]),t._v(" - 尋遍所有的可能解然後選取最好的解\n"),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/maximum-subarray",target:"_blank",rel:"noopener noreferrer"}},[t._v("最大子序列"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/travelling-salesman",target:"_blank",rel:"noopener noreferrer"}},[t._v("旅行推銷員問題"),r("OutboundLink")],1),t._v(" - shortest possible route that visits each city and returns to the origin city")])])]),r("li",[r("strong",[t._v("貪婪法")]),t._v(" - choose the best option at the current time, without any consideration for the future\n"),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/knapsack-problem",target:"_blank",rel:"noopener noreferrer"}},[t._v("未定背包問題"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/dijkstra",target:"_blank",rel:"noopener noreferrer"}},[t._v("Dijkstra 演算法"),r("OutboundLink")],1),t._v(" - 找到所有圖頂點的最短路徑")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/prim",target:"_blank",rel:"noopener noreferrer"}},[t._v("Prim’s 演算法"),r("OutboundLink")],1),t._v(" - finding Minimum Spanning Tree (MST) for weighted undirected graph")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/kruskal",target:"_blank",rel:"noopener noreferrer"}},[t._v("Kruskal’s 演算法"),r("OutboundLink")],1),t._v(" - finding Minimum Spanning Tree (MST) for weighted undirected graph")])])]),r("li",[r("strong",[t._v("分治法")]),t._v(" - divide the problem into smaller parts and then solve those parts\n"),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/search/binary-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("二元搜尋"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/hanoi-tower",target:"_blank",rel:"noopener noreferrer"}},[t._v("河內塔"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/euclidean-algorithm",target:"_blank",rel:"noopener noreferrer"}},[t._v("歐幾里得演算法"),r("OutboundLink")],1),t._v(" - calculate the Greatest Common Divisor (GCD)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/permutations",target:"_blank",rel:"noopener noreferrer"}},[t._v("排列"),r("OutboundLink")],1),t._v(" (有/無重複)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/combinations",target:"_blank",rel:"noopener noreferrer"}},[t._v("组合"),r("OutboundLink")],1),t._v(" (有/無重複)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/merge-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("合併排序"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/quick-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("快速排序"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/tree/depth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("樹深度優先搜尋"),r("OutboundLink")],1),t._v(" (DFS)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/depth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("圖深度優先搜尋"),r("OutboundLink")],1),t._v(" (DFS)")])])]),r("li",[r("strong",[t._v("動態編程")]),t._v(" - build up to a solution using previously found sub-solutions\n"),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/fibonacci",target:"_blank",rel:"noopener noreferrer"}},[t._v("費伯納西數列"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/levenshtein-distance",target:"_blank",rel:"noopener noreferrer"}},[t._v("萊溫斯坦距離"),r("OutboundLink")],1),t._v(" - minimum edit distance between two sequences")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/longest-common-subsequnce",target:"_blank",rel:"noopener noreferrer"}},[t._v("最長共同子序列"),r("OutboundLink")],1),t._v(" (LCS)")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/longest-common-substring",target:"_blank",rel:"noopener noreferrer"}},[t._v("最長共同子字串"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/longest-increasing-subsequence",target:"_blank",rel:"noopener noreferrer"}},[t._v("最長遞增子序列"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/shortest-common-supersequence",target:"_blank",rel:"noopener noreferrer"}},[t._v("最短共同子序列"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/knapsack-problem",target:"_blank",rel:"noopener noreferrer"}},[t._v("0/1背包問題"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/integer-partition",target:"_blank",rel:"noopener noreferrer"}},[t._v("整數拆分"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/maximum-subarray",target:"_blank",rel:"noopener noreferrer"}},[t._v("最大子序列"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/bellman-ford",target:"_blank",rel:"noopener noreferrer"}},[t._v("Bellman-Ford 演算法"),r("OutboundLink")],1),t._v(" - finding shortest path to all graph vertices")])])]),r("li",[r("strong",[t._v("回溯法")]),t._v(" - 用類似暴力法來嘗試產生所有可能解，但每次只在能滿足所有測試條件，且只有繼續產生子序列方案來產生的解決方案。否則回溯並尋找不同路徑的解決方案。\n"),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/hamiltonian-cycle",target:"_blank",rel:"noopener noreferrer"}},[t._v("漢彌爾頓迴路"),r("OutboundLink")],1),t._v(" - Visit every vertex exactly once")]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/n-queens",target:"_blank",rel:"noopener noreferrer"}},[t._v("N-皇后問題"),r("OutboundLink")],1)]),r("li",[r("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/knight-tour",target:"_blank",rel:"noopener noreferrer"}},[t._v("騎士走棋盤"),r("OutboundLink")],1)])])]),t._m(5)]),t._m(6),t._m(7),t._m(8),t._m(9),t._m(10),t._m(11),t._m(12),t._m(13),t._m(14),r("p",[t._v("接著直接執行下列的指令來測試你練習的 code 是否如預期運作：")]),t._m(15),t._m(16),t._m(17),r("p",[r("a",{attrs:{href:"https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8",target:"_blank",rel:"noopener noreferrer"}},[t._v("▶ Data Structures and Algorithms on YouTube"),r("OutboundLink")],1)]),t._m(18),r("p",[t._v("特別用大 O 標記演算法增長度的排序。")]),t._m(19),r("p",[t._v("資料來源: "),r("a",{attrs:{href:"http://bigocheatsheet.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Big O Cheat Sheet"),r("OutboundLink")],1),t._v(".")]),r("p",[t._v("下列列出幾個常用的 Big O 標記以及其不同大小資料量輸入後的運算效能比較。")]),t._m(20),t._m(21),t._m(22),t._m(23),t._m(24)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"javascript-演算法與資料結構"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-演算法與資料結構","aria-hidden":"true"}},[this._v("#")]),this._v(" JavaScript 演算法與資料結構")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"資料結構"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#資料結構","aria-hidden":"true"}},[this._v("#")]),this._v(" 資料結構")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"演算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#演算法","aria-hidden":"true"}},[this._v("#")]),this._v(" 演算法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"演算法議題分類"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#演算法議題分類","aria-hidden":"true"}},[this._v("#")]),this._v(" 演算法議題分類")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"演算法範型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#演算法範型","aria-hidden":"true"}},[this._v("#")]),this._v(" 演算法範型")])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("strong",[this._v("Branch & Bound")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"如何使用本知識庫"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何使用本知識庫","aria-hidden":"true"}},[this._v("#")]),this._v(" 如何使用本知識庫")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("安裝所有必須套件")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("npm install\n")])]),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[this._v("1")]),e("br")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("執行所有測試")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("npm test\n")])]),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[this._v("1")]),e("br")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("以名稱執行該測試")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("npm test -- -t 'LinkedList'\n")])]),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[this._v("1")]),e("br")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("練習場")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("你可以透過在"),e("code",[this._v("./src/playground/playground.js")]),this._v("裡面的檔案練習資料結構以及演算法，並且撰寫在"),e("code",[this._v("./src/playground/__test__/playground.test.js")]),this._v("裡面的測試程式。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("npm test -- -t 'playground'\n")])]),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[this._v("1")]),e("br")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"有用的資訊"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有用的資訊","aria-hidden":"true"}},[this._v("#")]),this._v(" 有用的資訊")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"參考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#參考","aria-hidden":"true"}},[this._v("#")]),this._v(" 參考")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"大-o-標記"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#大-o-標記","aria-hidden":"true"}},[this._v("#")]),this._v(" 大 O 標記")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://github.com/trekhleb/javascript-algorithms/blob/master/assets/big-o-graph.png?raw=true",alt:"Big O 表"}})])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("Big O 標記")]),r("th",[t._v("10個資料量需花費的時間")]),r("th",[t._v("100個資料量需花費的時間")]),r("th",[t._v("1000個資料量需花費的時間")])])]),r("tbody",[r("tr",[r("td",[r("strong",[t._v("O(1)")])]),r("td",[t._v("1")]),r("td",[t._v("1")]),r("td",[t._v("1")])]),r("tr",[r("td",[r("strong",[t._v("O(log N)")])]),r("td",[t._v("3")]),r("td",[t._v("6")]),r("td",[t._v("9")])]),r("tr",[r("td",[r("strong",[t._v("O(N)")])]),r("td",[t._v("10")]),r("td",[t._v("100")]),r("td",[t._v("1000")])]),r("tr",[r("td",[r("strong",[t._v("O(N log N)")])]),r("td",[t._v("30")]),r("td",[t._v("600")]),r("td",[t._v("9000")])]),r("tr",[r("td",[r("strong",[t._v("O(N^2)")])]),r("td",[t._v("100")]),r("td",[t._v("10000")]),r("td",[t._v("1000000")])]),r("tr",[r("td",[r("strong",[t._v("O(2^N)")])]),r("td",[t._v("1024")]),r("td",[t._v("1.26e+29")]),r("td",[t._v("1.07e+301")])]),r("tr",[r("td",[r("strong",[t._v("O(N!)")])]),r("td",[t._v("3628800")]),r("td",[t._v("9.3e+157")]),r("td",[t._v("4.02e+2567")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"資料結構運作複雜度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#資料結構運作複雜度","aria-hidden":"true"}},[this._v("#")]),this._v(" 資料結構運作複雜度")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("資料結構")]),r("th",{staticStyle:{"text-align":"center"}},[t._v("存取")]),r("th",{staticStyle:{"text-align":"center"}},[t._v("搜尋")]),r("th",{staticStyle:{"text-align":"center"}},[t._v("插入")]),r("th",{staticStyle:{"text-align":"center"}},[t._v("刪除")])])]),r("tbody",[r("tr",[r("td",[r("strong",[t._v("陣列")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")])]),r("tr",[r("td",[r("strong",[t._v("堆疊")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")])]),r("tr",[r("td",[r("strong",[t._v("貯列")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")])]),r("tr",[r("td",[r("strong",[t._v("鏈結串列")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")])]),r("tr",[r("td",[r("strong",[t._v("雜湊表")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("-")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")])]),r("tr",[r("td",[r("strong",[t._v("二元搜尋樹")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")])]),r("tr",[r("td",[r("strong",[t._v("B-Tree")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")])]),r("tr",[r("td",[r("strong",[t._v("紅黑樹")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")])]),r("tr",[r("td",[r("strong",[t._v("AVL Tree")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"陣列搜尋演算法複雜度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#陣列搜尋演算法複雜度","aria-hidden":"true"}},[this._v("#")]),this._v(" 陣列搜尋演算法複雜度")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",[r("thead",[r("tr",[r("th",[t._v("名稱")]),r("th",{staticStyle:{"text-align":"center"}},[t._v("最佳")]),r("th",{staticStyle:{"text-align":"center"}},[t._v("平均")]),r("th",{staticStyle:{"text-align":"center"}},[t._v("最差")]),r("th",{staticStyle:{"text-align":"center"}},[t._v("記憶體")]),r("th",{staticStyle:{"text-align":"center"}},[t._v("穩定")])])]),r("tbody",[r("tr",[r("td",[r("strong",[t._v("氣派排序")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("Yes")])]),r("tr",[r("td",[r("strong",[t._v("插入排序")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("Yes")])]),r("tr",[r("td",[r("strong",[t._v("選擇排序")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("No")])]),r("tr",[r("td",[r("strong",[t._v("Heap 排序")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("No")])]),r("tr",[r("td",[r("strong",[t._v("合併排序")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("Yes")])]),r("tr",[r("td",[r("strong",[t._v("快速排序")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("No")])]),r("tr",[r("td",[r("strong",[t._v("希爾排序")])]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("由gap sequence決定")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("n (log(n))^2")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),r("td",{staticStyle:{"text-align":"center"}},[t._v("No")])])])])}],!1,null,null,null);e.default=s.exports}}]);