(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{159:function(t,r,e){"use strict";e.r(r);var a=e(0),s=Object(a.a)({},function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("div",{staticClass:"content"},[t._m(0),e("p",[e("a",{attrs:{href:"https://travis-ci.org/trekhleb/javascript-algorithms",target:"_blank",rel:"noopener noreferrer"}},[e("img",{attrs:{src:"https://travis-ci.org/trekhleb/javascript-algorithms.svg?branch=master",alt:"build status"}}),e("OutboundLink")],1),e("a",{attrs:{href:"https://codecov.io/gh/trekhleb/javascript-algorithms",target:"_blank",rel:"noopener noreferrer"}},[e("img",{attrs:{src:"https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg",alt:"codecov"}}),e("OutboundLink")],1)]),e("p",[t._v("本仓库包含了多种基于 JavaScript 的算法与数据结构。")]),e("p",[t._v("每种算法和数据结构都有自己的 README 并提供相关说明以及进一步阅读和 YouTube 视频。")]),e("p",[e("em",[t._v("Read this in other languages:")]),e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/",target:"_blank",rel:"noopener noreferrer"}},[e("em",[t._v("English")]),e("OutboundLink")],1),t._v(",\n"),e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-TW.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("繁體中文"),e("OutboundLink")],1)]),t._m(1),e("p",[t._v("数据结构是在计算机中组织和存储数据的一种特殊方式，它可以高效地访问和修改数据。更确切地说，数据结构是数据值的集合，它们之间的关系、函数或操作可以应用于数据。")]),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/linked-list",target:"_blank",rel:"noopener noreferrer"}},[t._v("链表"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/queue",target:"_blank",rel:"noopener noreferrer"}},[t._v("队列"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/stack",target:"_blank",rel:"noopener noreferrer"}},[t._v("栈"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/hash-table",target:"_blank",rel:"noopener noreferrer"}},[t._v("哈希表"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/heap",target:"_blank",rel:"noopener noreferrer"}},[t._v("堆"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/priority-queue",target:"_blank",rel:"noopener noreferrer"}},[t._v("优先队列"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/trie",target:"_blank",rel:"noopener noreferrer"}},[t._v("字典树"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/tree",target:"_blank",rel:"noopener noreferrer"}},[t._v("树"),e("OutboundLink")],1),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/tree/binary-search-tree",target:"_blank",rel:"noopener noreferrer"}},[t._v("二分查找"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/tree/avl-tree",target:"_blank",rel:"noopener noreferrer"}},[t._v("AVL 树"),e("OutboundLink")],1)]),e("li",[t._v("红黑树")]),e("li",[t._v("后缀树")]),e("li",[t._v("线段树 或 间隔树")]),e("li",[t._v("二叉索引树")])])]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/graph",target:"_blank",rel:"noopener noreferrer"}},[t._v("图"),e("OutboundLink")],1),t._v(" (有向图与无向图)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/disjoint-set",target:"_blank",rel:"noopener noreferrer"}},[t._v("并查集"),e("OutboundLink")],1)])]),t._m(2),e("p",[t._v("算法是如何解决一类问题的明确规范。 算法是一组精确定义操作序列的规则。")]),t._m(3),e("ul",[e("li",[e("strong",[t._v("数学")]),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/factorial",target:"_blank",rel:"noopener noreferrer"}},[t._v("阶乘"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/fibonacci",target:"_blank",rel:"noopener noreferrer"}},[t._v("斐波那契数"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/primality-test",target:"_blank",rel:"noopener noreferrer"}},[t._v("素数检测"),e("OutboundLink")],1),t._v(" (排除法)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/euclidean-algorithm",target:"_blank",rel:"noopener noreferrer"}},[t._v("欧几里得算法"),e("OutboundLink")],1),t._v(" - 计算最大公约数（GCD）")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/least-common-multiple",target:"_blank",rel:"noopener noreferrer"}},[t._v("最小公倍数"),e("OutboundLink")],1),t._v(" (LCM)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/integer-partition",target:"_blank",rel:"noopener noreferrer"}},[t._v("整数拆分"),e("OutboundLink")],1)])])]),e("li",[e("strong",[t._v("集合")]),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/cartesian-product",target:"_blank",rel:"noopener noreferrer"}},[t._v("笛卡尔积"),e("OutboundLink")],1),t._v(" - 多集合结果")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/power-set",target:"_blank",rel:"noopener noreferrer"}},[t._v("幂集"),e("OutboundLink")],1),t._v(" - 该集合的所有子集")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/permutations",target:"_blank",rel:"noopener noreferrer"}},[t._v("排列"),e("OutboundLink")],1),t._v(" (有/无重复)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/combinations",target:"_blank",rel:"noopener noreferrer"}},[t._v("组合"),e("OutboundLink")],1),t._v(" (有/无重复)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/fisher-yates",target:"_blank",rel:"noopener noreferrer"}},[t._v("洗牌算法"),e("OutboundLink")],1),t._v(" - 随机置换有限序列")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/longest-common-subsequnce",target:"_blank",rel:"noopener noreferrer"}},[t._v("最长公共子序列"),e("OutboundLink")],1),t._v(" (LCS)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/longest-increasing-subsequence",target:"_blank",rel:"noopener noreferrer"}},[t._v("最长递增子序列"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/shortest-common-supersequence",target:"_blank",rel:"noopener noreferrer"}},[t._v("Shortest Common Supersequence"),e("OutboundLink")],1),t._v(" (SCS)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/knapsack-problem",target:"_blank",rel:"noopener noreferrer"}},[t._v("背包问题"),e("OutboundLink")],1),t._v(' - "0/1" and "Unbound" ones')]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/maximum-subarray",target:"_blank",rel:"noopener noreferrer"}},[t._v("最大子数列问题"),e("OutboundLink")],1),t._v(" - BF算法 与 动态编程")])])]),e("li",[e("strong",[t._v("字符串")]),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/levenshtein-distance",target:"_blank",rel:"noopener noreferrer"}},[t._v("莱温斯坦距离"),e("OutboundLink")],1),t._v(" - 两个序列之间的最小编辑距离")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/hamming-distance",target:"_blank",rel:"noopener noreferrer"}},[t._v("汉明距离"),e("OutboundLink")],1),t._v(" - 符号不同的位置数")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/knuth-morris-pratt",target:"_blank",rel:"noopener noreferrer"}},[t._v("克努斯-莫里斯-普拉特算法"),e("OutboundLink")],1),t._v(" - 子串搜索")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/rabin-karp",target:"_blank",rel:"noopener noreferrer"}},[t._v("字符串快速查找"),e("OutboundLink")],1),t._v(" - 子串搜索")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/longest-common-substring",target:"_blank",rel:"noopener noreferrer"}},[t._v("最长公共子串"),e("OutboundLink")],1)])])]),e("li",[e("strong",[t._v("搜索")]),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/search/binary-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("二分查找"),e("OutboundLink")],1)])])]),e("li",[e("strong",[t._v("排序")]),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/bubble-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("冒泡排序"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/selection-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("选择排序"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/insertion-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("插入排序"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/heap-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("堆排序"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/merge-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("归并排序"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/quick-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("快速排序"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/shell-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("希尔排序"),e("OutboundLink")],1)])])]),e("li",[e("strong",[t._v("树")]),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/tree/depth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("深度优先搜索"),e("OutboundLink")],1),t._v(" (DFS)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/tree/breadth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("广度优先搜索"),e("OutboundLink")],1),t._v(" (BFS)")])])]),e("li",[e("strong",[t._v("图")]),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/depth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("深度优先搜索"),e("OutboundLink")],1),t._v(" (DFS)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/breadth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("广度优先搜索"),e("OutboundLink")],1),t._v(" (BFS)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/dijkstra",target:"_blank",rel:"noopener noreferrer"}},[t._v("戴克斯特拉算法m"),e("OutboundLink")],1),t._v(" - 找到所有图顶点的最短路径")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/bellman-ford",target:"_blank",rel:"noopener noreferrer"}},[t._v("贝尔曼-福特算法"),e("OutboundLink")],1),t._v(" - 找到所有图顶点的最短路径")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/detect-cycle",target:"_blank",rel:"noopener noreferrer"}},[t._v("判圈算法"),e("OutboundLink")],1),t._v(" - 对于有向图和无向图（基于DFS和不相交集的版本）")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/prim",target:"_blank",rel:"noopener noreferrer"}},[t._v("普林演算法"),e("OutboundLink")],1),t._v(" - 寻找加权无向图的最小生成树（MST）")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/kruskal",target:"_blank",rel:"noopener noreferrer"}},[t._v("克鲁斯克尔演算法"),e("OutboundLink")],1),t._v(" - 寻找加权无向图的最小生成树（MST）")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/topological-sorting",target:"_blank",rel:"noopener noreferrer"}},[t._v("拓撲排序"),e("OutboundLink")],1),t._v(" - DFS 方法")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/articulation-points",target:"_blank",rel:"noopener noreferrer"}},[t._v("关节点"),e("OutboundLink")],1),t._v(" - Tarjan算法（基于DFS）")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/bridges",target:"_blank",rel:"noopener noreferrer"}},[t._v("桥"),e("OutboundLink")],1),t._v(" - 基于DFS的算法")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/eulerian-path",target:"_blank",rel:"noopener noreferrer"}},[t._v("欧拉路径与一笔画问题"),e("OutboundLink")],1),t._v(" - Fleury的算法 - 一次访问每个边缘")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/hamiltonian-cycle",target:"_blank",rel:"noopener noreferrer"}},[t._v("哈密顿图"),e("OutboundLink")],1),t._v(" - 恰好访问每个顶点一次")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/strongly-connected-components",target:"_blank",rel:"noopener noreferrer"}},[t._v("强连通分量"),e("OutboundLink")],1),t._v(" - Kosaraju算法")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/travelling-salesman",target:"_blank",rel:"noopener noreferrer"}},[t._v("旅行推销员问题"),e("OutboundLink")],1),t._v(" - 尽可能以最短的路线访问每个城市并返回原始城市")])])]),e("li",[e("strong",[t._v("未分类")]),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/hanoi-tower",target:"_blank",rel:"noopener noreferrer"}},[t._v("汉诺塔"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/n-queens",target:"_blank",rel:"noopener noreferrer"}},[t._v("八皇后问题"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/knight-tour",target:"_blank",rel:"noopener noreferrer"}},[t._v("骑士巡逻"),e("OutboundLink")],1)])])])]),t._m(4),e("p",[t._v("算法范式是基于类的设计的通用方法或方法的算法。 这是一个比算法概念更高的抽象，就像一个\n算法是比计算机程序更高的抽象。")]),e("ul",[e("li",[t._m(5),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/maximum-subarray",target:"_blank",rel:"noopener noreferrer"}},[t._v("最大子数列"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/travelling-salesman",target:"_blank",rel:"noopener noreferrer"}},[t._v("旅行推销员问题"),e("OutboundLink")],1),t._v(" - 尽可能以最短的路线访问每个城市并返回原始城市")])])]),e("li",[t._m(6),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/knapsack-problem",target:"_blank",rel:"noopener noreferrer"}},[t._v("背包问题"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/dijkstra",target:"_blank",rel:"noopener noreferrer"}},[t._v("戴克斯特拉算法"),e("OutboundLink")],1),t._v(" - 找到所有图顶点的最短路径")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/prim",target:"_blank",rel:"noopener noreferrer"}},[t._v("普里姆算法"),e("OutboundLink")],1),t._v(" - 寻找加权无向图的最小生成树（MST）")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/kruskal",target:"_blank",rel:"noopener noreferrer"}},[t._v("克鲁斯卡尔算法"),e("OutboundLink")],1),t._v(" - 寻找加权无向图的最小生成树（MST）")])])]),e("li",[t._m(7),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/search/binary-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("二分查找"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/hanoi-tower",target:"_blank",rel:"noopener noreferrer"}},[t._v("汉诺塔"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/euclidean-algorithm",target:"_blank",rel:"noopener noreferrer"}},[t._v("欧几里得算法"),e("OutboundLink")],1),t._v(" - 计算最大公约数（GCD）")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/permutations",target:"_blank",rel:"noopener noreferrer"}},[t._v("排列"),e("OutboundLink")],1),t._v(" (有/无重复)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/combinations",target:"_blank",rel:"noopener noreferrer"}},[t._v("组合"),e("OutboundLink")],1),t._v(" (有/无重复)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/merge-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("归并排序"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/quick-sort",target:"_blank",rel:"noopener noreferrer"}},[t._v("Quicksort"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/tree/depth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("树深度优先搜索"),e("OutboundLink")],1),t._v(" (DFS)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/depth-first-search",target:"_blank",rel:"noopener noreferrer"}},[t._v("图深度优先搜索"),e("OutboundLink")],1),t._v(" (DFS)")])])]),e("li",[t._m(8),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/fibonacci",target:"_blank",rel:"noopener noreferrer"}},[t._v("斐波那契数"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/levenshtein-distance",target:"_blank",rel:"noopener noreferrer"}},[t._v("莱温斯坦距离"),e("OutboundLink")],1),t._v(" - 两个序列之间的最小编辑距离")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/longest-common-subsequnce",target:"_blank",rel:"noopener noreferrer"}},[t._v("最长公共子序列"),e("OutboundLink")],1),t._v(" (LCS)")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/longest-common-substring",target:"_blank",rel:"noopener noreferrer"}},[t._v("最长公共子串"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/longest-increasing-subsequence",target:"_blank",rel:"noopener noreferrer"}},[t._v("最长递增子序列"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/shortest-common-supersequence",target:"_blank",rel:"noopener noreferrer"}},[t._v("最短公共子序列"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/knapsack-problem",target:"_blank",rel:"noopener noreferrer"}},[t._v("0-1背包问题"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/integer-partition",target:"_blank",rel:"noopener noreferrer"}},[t._v("整数拆分"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sets/maximum-subarray",target:"_blank",rel:"noopener noreferrer"}},[t._v("最大子数列"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/bellman-ford",target:"_blank",rel:"noopener noreferrer"}},[t._v("贝尔曼-福特算法"),e("OutboundLink")],1),t._v(" - 找到所有图顶点的最短路径")])])]),e("li",[t._m(9),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/graph/hamiltonian-cycle",target:"_blank",rel:"noopener noreferrer"}},[t._v("哈密顿图"),e("OutboundLink")],1),t._v(" - 恰好访问每个顶点一次")]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/n-queens",target:"_blank",rel:"noopener noreferrer"}},[t._v("八皇后问题"),e("OutboundLink")],1)]),e("li",[e("a",{attrs:{href:"https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/uncategorized/knight-tour",target:"_blank",rel:"noopener noreferrer"}},[t._v("骑士巡逻"),e("OutboundLink")],1)])])]),t._m(10)]),t._m(11),t._m(12),t._m(13),t._m(14),t._m(15),t._m(16),t._m(17),t._m(18),t._m(19),e("p",[t._v("然后，只需运行以下命令来测试你的 Playground 是否按无误:")]),t._m(20),t._m(21),t._m(22),e("p",[e("a",{attrs:{href:"https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8",target:"_blank",rel:"noopener noreferrer"}},[t._v("▶ YouTube"),e("OutboundLink")],1)]),t._m(23),e("p",[t._v("大O符号中指定的算法的增长顺序。")]),t._m(24),e("p",[t._v("源: "),e("a",{attrs:{href:"http://bigocheatsheet.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Big O Cheat Sheet"),e("OutboundLink")],1),t._v(".")]),e("p",[t._v("以下是一些最常用的 大O标记法 列表以及它们与不同大小输入数据的性能比较。")]),t._m(25),t._m(26),t._m(27),t._m(28),t._m(29)])},[function(){var t=this.$createElement,r=this._self._c||t;return r("h1",{attrs:{id:"javascript-算法与数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript-算法与数据结构","aria-hidden":"true"}},[this._v("#")]),this._v(" JavaScript 算法与数据结构")])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据结构","aria-hidden":"true"}},[this._v("#")]),this._v(" 数据结构")])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法","aria-hidden":"true"}},[this._v("#")]),this._v(" 算法")])},function(){var t=this.$createElement,r=this._self._c||t;return r("h3",{attrs:{id:"算法主题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法主题","aria-hidden":"true"}},[this._v("#")]),this._v(" 算法主题")])},function(){var t=this.$createElement,r=this._self._c||t;return r("h3",{attrs:{id:"算法范式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法范式","aria-hidden":"true"}},[this._v("#")]),this._v(" 算法范式")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("BF算法")]),this._v(" - 查找所有可能性并选择最佳解决方案")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("贪心法")]),this._v(" - 在当前选择最佳选项，不考虑以后情况")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("分治法")]),this._v(" - 将问题分成较小的部分，然后解决这些部分")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("动态编程")]),this._v(" - 使用以前找到的子解决方案构建解决方案")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("回溯法")]),this._v(" - 类似于 BF算法 试图产生所有可能的解决方案，但每次生成解决方案测试如果它满足所有条件，那么只有继续生成后续解决方案。 否则回溯并继续寻找不同路径的解决方案。")])},function(){var t=this.$createElement,r=this._self._c||t;return r("li",[r("p",[r("strong",[this._v("B & B")])])])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"如何使用本仓库"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何使用本仓库","aria-hidden":"true"}},[this._v("#")]),this._v(" 如何使用本仓库")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("安装依赖")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[this._v("npm install\n")])]),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[this._v("1")]),r("br")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("执行测试")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[this._v("npm test\n")])]),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[this._v("1")]),r("br")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("按照名称执行测试")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[this._v("npm test -- -t 'LinkedList'\n")])]),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[this._v("1")]),r("br")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("strong",[this._v("Playground")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[this._v("你可以在"),r("code",[this._v("./src/playground/playground.js")]),this._v("文件中操作数据结构与算法，并在"),r("code",[this._v("./src/playground/__test__/playground.test.js")]),this._v("中编写测试。")])},function(){var t=this.$createElement,r=this._self._c||t;return r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[this._v("npm test -- -t 'playground'\n")])]),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[this._v("1")]),r("br")])])},function(){var t=this.$createElement,r=this._self._c||t;return r("h2",{attrs:{id:"有用的信息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#有用的信息","aria-hidden":"true"}},[this._v("#")]),this._v(" 有用的信息")])},function(){var t=this.$createElement,r=this._self._c||t;return r("h3",{attrs:{id:"引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用","aria-hidden":"true"}},[this._v("#")]),this._v(" 引用")])},function(){var t=this.$createElement,r=this._self._c||t;return r("h3",{attrs:{id:"大o符号"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#大o符号","aria-hidden":"true"}},[this._v("#")]),this._v(" 大O符号")])},function(){var t=this.$createElement,r=this._self._c||t;return r("p",[r("img",{attrs:{src:"https://github.com/trekhleb/javascript-algorithms/blob/master/assets/big-o-graph.png?raw=true",alt:"Big O graphs"}})])},function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("table",[e("thead",[e("tr",[e("th",[t._v("大O标记法")]),e("th",[t._v("计算10个元素")]),e("th",[t._v("计算100个元素")]),e("th",[t._v("计算1000个元素")])])]),e("tbody",[e("tr",[e("td",[e("strong",[t._v("O(1)")])]),e("td",[t._v("1")]),e("td",[t._v("1")]),e("td",[t._v("1")])]),e("tr",[e("td",[e("strong",[t._v("O(log N)")])]),e("td",[t._v("3")]),e("td",[t._v("6")]),e("td",[t._v("9")])]),e("tr",[e("td",[e("strong",[t._v("O(N)")])]),e("td",[t._v("10")]),e("td",[t._v("100")]),e("td",[t._v("1000")])]),e("tr",[e("td",[e("strong",[t._v("O(N log N)")])]),e("td",[t._v("30")]),e("td",[t._v("600")]),e("td",[t._v("9000")])]),e("tr",[e("td",[e("strong",[t._v("O(N^2)")])]),e("td",[t._v("100")]),e("td",[t._v("10000")]),e("td",[t._v("1000000")])]),e("tr",[e("td",[e("strong",[t._v("O(2^N)")])]),e("td",[t._v("1024")]),e("td",[t._v("1.26e+29")]),e("td",[t._v("1.07e+301")])]),e("tr",[e("td",[e("strong",[t._v("O(N!)")])]),e("td",[t._v("3628800")]),e("td",[t._v("9.3e+157")]),e("td",[t._v("4.02e+2567")])])])])},function(){var t=this.$createElement,r=this._self._c||t;return r("h3",{attrs:{id:"数据结构操作的复杂性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据结构操作的复杂性","aria-hidden":"true"}},[this._v("#")]),this._v(" 数据结构操作的复杂性")])},function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("table",[e("thead",[e("tr",[e("th",[t._v("数据结构")]),e("th",{staticStyle:{"text-align":"center"}},[t._v("连接")]),e("th",{staticStyle:{"text-align":"center"}},[t._v("查找")]),e("th",{staticStyle:{"text-align":"center"}},[t._v("插入")]),e("th",{staticStyle:{"text-align":"center"}},[t._v("删除")])])]),e("tbody",[e("tr",[e("td",[e("strong",[t._v("数组")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")])]),e("tr",[e("td",[e("strong",[t._v("栈")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")])]),e("tr",[e("td",[e("strong",[t._v("队列")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")])]),e("tr",[e("td",[e("strong",[t._v("链表")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")])]),e("tr",[e("td",[e("strong",[t._v("哈希表")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("-")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")])]),e("tr",[e("td",[e("strong",[t._v("二分查找树")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")])]),e("tr",[e("td",[e("strong",[t._v("B树")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")])]),e("tr",[e("td",[e("strong",[t._v("红黑树")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")])]),e("tr",[e("td",[e("strong",[t._v("AVL树")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")])])])])},function(){var t=this.$createElement,r=this._self._c||t;return r("h3",{attrs:{id:"数组排序算法的复杂性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组排序算法的复杂性","aria-hidden":"true"}},[this._v("#")]),this._v(" 数组排序算法的复杂性")])},function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("table",[e("thead",[e("tr",[e("th",[t._v("名称")]),e("th",{staticStyle:{"text-align":"center"}},[t._v("最优")]),e("th",{staticStyle:{"text-align":"center"}},[t._v("平均")]),e("th",{staticStyle:{"text-align":"center"}},[t._v("最坏")]),e("th",{staticStyle:{"text-align":"center"}},[t._v("内存")]),e("th",{staticStyle:{"text-align":"center"}},[t._v("稳定")])])]),e("tbody",[e("tr",[e("td",[e("strong",[t._v("冒泡排序")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("Yes")])]),e("tr",[e("td",[e("strong",[t._v("插入排序")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("Yes")])]),e("tr",[e("td",[e("strong",[t._v("选择排序")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("No")])]),e("tr",[e("td",[e("strong",[t._v("堆排序")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("No")])]),e("tr",[e("td",[e("strong",[t._v("归并排序")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("Yes")])]),e("tr",[e("td",[e("strong",[t._v("快速排序")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n^2")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("No")])]),e("tr",[e("td",[e("strong",[t._v("希尔排序")])]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n log(n)")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("取决于差距序列")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("n (log(n))^2")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),e("td",{staticStyle:{"text-align":"center"}},[t._v("No")])])])])}],!1,null,null,null);r.default=s.exports}}]);